1. Maximum Depth of Binary Tree (https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {

        if(root==null)
          return 0;
        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));
        
    }
}



2. Balanced Binary Tree (https://leetcode.com/problems/balanced-binary-tree/description/)


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */

Approach:: 1

class Solution {
    int height(TreeNode root)
    {
        if(root==null)
          return 0;
        return 1+ Math.max(height(root.left),height(root.right));
    }
    public boolean isBalanced(TreeNode root) {

        if(root==null)
          return true;
        int leftHeight=height(root.left);
        int rightHeight=height(root.right);
        return Math.abs(leftHeight-rightHeight)<=1
              && isBalanced(root.left) && isBalanced(root.right);
    }
}



Approach:: 2

class Solution {
    int height(TreeNode root)
    {
        if(root==null)
          return 0;
        int lH=height(root.left);
        if(lH == -1) 
           return -1;
        int rH=height(root.right);
        if(rH == -1)
          return -1;
        if(Math.abs(lH-rH)>1) 
          return -1;
        return 1+ Math.max(height(root.left),height(root.right));
    }
    public boolean isBalanced(TreeNode root) {
        
        return height(root)==-1?false:true;
    }
}



3. Diameter of Binary Tree (https://leetcode.com/problems/diameter-of-binary-tree/description/)



Approach:: 1

Find Left height, right height of every subtree.
Time Complexity:: O(N^2)
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int max=Integer.MIN_VALUE;
    public int height(TreeNode root)
    {
        if(root==null)
          return 0;
        return Math.max(height(root.left),height(root.right))+1;
    }
    public int diameterOfBinaryTree(TreeNode root) {

        if(root==null)
          return 0;
        int lh=height(root.left);
        int rh=height(root.right);
        max=Math.max(max,lh+rh);
        diameterOfBinaryTree(root.left);
        diameterOfBinaryTree(root.right);
        return max;
        
    }
}

Approach:: 2

Time Complexity:: O(N)
class Solution {
    public int max=Integer.MIN_VALUE;
    public int height(TreeNode root)
    {
        if(root==null)
          return 0;
        int lh=height(root.left);
        int rh=height(root.right);
        max=Math.max(max,lh+rh);
        return 1+Math.max(lh,rh);
        
    }
    public int diameterOfBinaryTree(TreeNode root) {
        
         height(root);
         return max;
    }
}


4. Binary Tree Maximum Path Sum (https://leetcode.com/problems/binary-tree-maximum-path-sum/description/)

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int maxi  = Integer.MIN_VALUE;
    public int maxSum(TreeNode root){
        if(root == null) {
            return 0;
        }
        int lSum = Math.max(0, maxSum(root.left));
        int rSum = Math.max(0, maxSum(root.right));
        maxi = Math.max(maxi,lSum+rSum+root.val);
        return root.val + Math.max(lSum, rSum);
    }
    public int maxPathSum(TreeNode root) {
        maxSum(root);
        return maxi;
    }
}


5. Check it two trees are Identical or Not (Same Tree) (https://leetcode.com/problems/same-tree/description/)


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {

        if(p==null && q==null)
          return true;
        if(p==null||q==null)
          return false;
        return (p.val==q.val?true:false) 
               && isSameTree(p.left,q.left) 
               && isSameTree(p.right,q.right);
        
    }
}


6. Binary Tree Zigzag Level Order Traversal (https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)


/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {

     List<List<Integer>> zigZag = new ArrayList<>();
     if(root == null) {
        return zigZag;
      }
    Queue<TreeNode> q = new LinkedList<>();
    q.add(root);
    int flag = 0;
    while(!q.isEmpty())  {
        int size = q.size();
        List<Integer> inner = new ArrayList<>();
        for(int i = 0;i<size;i++) {
            TreeNode node = q.poll();
            if(node.left != null)
               q.add(node.left);
            if(node.right != null) 
               q.add(node.right);
            inner.add(node.val);
        }
        if(flag == 0) {
            zigZag.add(inner);
        }
        else {
            Collections.reverse(inner);
            zigZag.add(inner);
        }
        flag = 1 - flag;
    } 

    return zigZag;
    }
}



7. Boundary Traversal of binary tree
: (https://www.geeksforgeeks.org/problems/boundary-traversal-of-binary-tree/1)


class Solution {
	private void addLeftBoundary(Node node, ArrayList<Integer> ans) {
		Node curr = node.left;

		while (curr != null) {
			if (isLeaf(curr) == false) {
				ans.add(curr.data);
			}
			if (curr.left != null)
				curr = curr.left;
			else
				curr = curr.right;
		}
	}

	private void addRightBpundary(Node node, ArrayList<Integer> ans) {
		Node curr = node.right;
		ArrayList<Integer> rightTree = new ArrayList<>();
		while (curr != null) {
			if (isLeaf(curr) == false) {
				rightTree.add(curr.data);
			}
			if (curr.right != null)
				curr = curr.right;
			else
				curr = curr.left;
		}
		for (int i = rightTree.size() - 1; i >= 0; i--) {
			ans.add(rightTree.get(i));
		}
	}

	private void addLeaf(Node node, ArrayList<Integer> ans) {
		if (isLeaf(node) == true) {
			ans.add(node.data);
			return;
		}
		if (node.left != null)
			addLeaf(node.left, ans);
		if (node.right != null)
			addLeaf(node.right, ans);
	}

	private boolean isLeaf(Node node) {
		return node != null && node.left == null && node.right == null;
	}

	ArrayList<Integer> boundary(Node node) {

		ArrayList<Integer> ans = new ArrayList<>();
		if (node == null) {
			return ans;
		}
		if (isLeaf(node) == false)
			ans.add(node.data);
		addLeftBoundary(node, ans);
		addLeaf(node, ans);
		addRightBpundary(node, ans);

		return ans;
	}
}




8. Vertical Order Traversal of a Binary Tree:: (https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/description/)



/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> verticalTraversal(TreeNode root) {

        List<List<Integer>> verticalOrder = new ArrayList<>();

        if(root == null){
            return verticalOrder;
        }
        TreeMap<Integer,TreeMap<Integer,PriorityQueue<Integer>>> tMap = new TreeMap<>();
        Queue<Node> q = new LinkedList<Node>();
        q.add(new Node(root,0,0));

        while(!q.isEmpty()) {
                Node n = q.poll();
                TreeNode node = n.node;
                int x = n.vertical;
                int y = n.level; 
                if(tMap.containsKey(x) == false) {
                    tMap.put(x,new TreeMap<>());
                }
                if(tMap.get(x).containsKey(y) == false) {
                    tMap.get(x).put(y,new PriorityQueue<>());
                }

                tMap.get(x).get(y).add(node.val);

                if(node.left != null){
                    q.add(new Node(node.left,x-1,y+1));
                }
                if(node.right != null){
                    q.add(new Node(node.right, x+1,y+1));
                }
        }

        for(TreeMap<Integer,PriorityQueue<Integer>> mq: tMap.values()){
            verticalOrder.add(new ArrayList<>());
            for(PriorityQueue<Integer> nodes: mq.values()){
                while(!nodes.isEmpty()){
                    verticalOrder.get(verticalOrder.size() - 1).add(nodes.poll());
                }
            }
        }

        return verticalOrder;
    }
}

class Node {
    TreeNode node;
    int vertical;
    int level;

    Node(TreeNode node, int vertical, int level) {
        this.node = node;
        this.vertical = vertical;
        this.level = level;
    }
}




9. Top View of Binary Tree:: (https://www.geeksforgeeks.org/problems/top-view-of-binary-tree/1)


class Solution {
	// Function to return a list of nodes visible from the top view
	// from left to right in Binary Tree.
	static ArrayList<Integer> topView(Node root) {

		ArrayList<Integer> ans = new ArrayList<>();

		if (root == null) {
			return ans;
		}

		Queue<Pair> q = new LinkedList<>();
		q.add(new Pair(root, 0));
		Map<Integer, Integer> mp = new TreeMap<>();
		while (!q.isEmpty()) {
			Pair p = q.poll();

			Node node = p.node;
			int x = p.vLevel;

			if (mp.containsKey(x) == false) {
				mp.put(x, node.data);
			}
			if (node.left != null) {
				q.add(new Pair(node.left, x - 1));
			}
			if (node.right != null) {
				q.add(new Pair(node.right, x + 1));
			}

		}
		for (Integer m : mp.values()) {
			ans.add(m);
		}

		return ans;
	}
}

class Pair {

	Node node;
	int vLevel;

	Pair(Node node, int vLevel) {
		this.node = node;
		this.vLevel = vLevel;
	}
}




10. Bottom View of Binary Tree
: (https://www.geeksforgeeks.org/problems/bottom-view-of-binary-tree/1)


class Solution {

	// Function to return a list containing the bottom view of the given tree.
	public ArrayList<Integer> bottomView(Node root) {
		ArrayList<Integer> ans = new ArrayList<>();

		if (root == null) {
			return ans;
		}
		Queue<Pair> q = new LinkedList<>();

		Map<Integer, Integer> mp = new TreeMap<>();

		q.add(new Pair(root, 0));

		while (!q.isEmpty()) {
			Pair p = q.poll();

			Node node = p.node;
			int x = p.vLevel;
			mp.put(x, node.data);
			if (node.left != null)
				q.add(new Pair(node.left, x - 1));
			if (node.right != null)
				q.add(new Pair(node.right, x + 1));
		}
		for (Integer i : mp.values()) {
			ans.add(i);
		}
		return ans;
	}
}

class Pair {

	Node node;
	int vLevel;

	Pair(Node node, int vLevel) {
		this.node = node;
		this.vLevel = vLevel;
	}
}


11. Binary Tree Right Side View: (https://leetcode.com/problems/binary-tree-right-side-view/description/)



/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        
        List<Integer> ans = new ArrayList<>();
        if(root == null){
            return ans;
        }
        List<List<Integer>> level = new ArrayList<>();

        Queue<TreeNode> q = new LinkedList<>();
        q.add(root);
        
        while(!q.isEmpty()) {
            int size = q.size();
            List<Integer> inner = new ArrayList<>();
            for(int i = 0;i<size;i++) {
                TreeNode node = q.poll();
                if(node.left != null)
                  q.add(node.left);
                if(node.right != null) 
                  q.add(node.right);
                inner.add(node.val); 
            }
            level.add(inner);
        }
        for(int i =0;i<level.size();i++) {
            ans.add(level.get(i).get(level.get(i).size() - 1));
        }

        return ans;
    }
}



12. Left View of Binary Tree: (https://www.geeksforgeeks.org/problems/left-view-of-binary-tree/1)


class Tree {

	// Function to return list containing elements of left view of binary tree.
	ArrayList<Integer> leftView(Node root) {
		ArrayList<Integer> ans = new ArrayList<>();
		if (root == null) {
			return ans;
		}

		List<List<Integer>> level = new ArrayList<>();

		Queue<Node> q = new LinkedList<>();

		q.add(root);

		while (!q.isEmpty()) {
			int size = q.size();

			List<Integer> inner = new ArrayList<>();
			for (int i = 0; i < size; i++) {
				Node node = q.poll();

				if (node.left != null)
					q.add(node.left);
				if (node.right != null)
					q.add(node.right);
				inner.add(node.data);
			}

			level.add(inner);
		}

		for (int i = 0; i < level.size(); i++) {
			ans.add(level.get(i).get(0));
		}
		return ans;
	}
}
