1. Introduction to Graph (https://takeuforward.org/graph/introduction-to-graph/)

2. Graph Representation (https://takeuforward.org/graph/graph-representation-in-c/)

3.Connected Components in Graphs (https://takeuforward.org/graph/connected-components-in-graphs/)

4.Breadth First Search (BFS): Level Order Traversal (https://takeuforward.org/graph/breadth-first-search-bfs-level-order-traversal/)


Problem Link :: https://www.geeksforgeeks.org/problems/bfs-traversal-of-graph/1


Solution:: 

class Solution {
    // Function to return Breadth First Traversal of given graph.
    public ArrayList<Integer> bfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        // Code here
        
        int vis[]= new int[V+1];
        for(int i=0;i<=V;i++)
        {
            vis[i]=0;
        }
        Queue<Integer> q = new LinkedList<>();
        
        q.add(0);
        vis[0]=1;
        ArrayList<Integer> res = new ArrayList<>();
        while(!q.isEmpty())
        {
          Integer val= q.poll();
          res.add(val);
          List<Integer> list = adj.get(val);
          for(int i=0;i<list.size();i++)
          {
              if(vis[list.get(i)]==0)
                {
                    q.add(list.get(i));
                    vis[list.get(i)]=1;
                }
          }
        }
        return res;
    }
}



5. Depth First Search (DFS) (https://takeuforward.org/data-structure/depth-first-search-dfs/)


Problem Link :: https://www.geeksforgeeks.org/problems/depth-first-traversal-for-a-graph/1

Solution :: 


class Solution {
    
    ArrayList<Integer> dfsArray;
    void dfs(int node,ArrayList<ArrayList<Integer>> adj,int vis[])
    {
        
        dfsArray.add(node);
        vis[node]=1;
        ArrayList<Integer> list = adj.get(node);
        for( int i=0;i<list.size();i++)
        {
            if(vis[list.get(i)]==0)
              {
                  dfs(list.get(i),adj,vis);
              }
        }
    }
    // Function to return a list containing the DFS traversal of the graph.
    public ArrayList<Integer> dfsOfGraph(int V, ArrayList<ArrayList<Integer>> adj) {
        // Code here
        
        int vis [] = new int[V+1];
        for(int i=0;i<=V;i++)
          vis[i]=0;
        dfsArray=new ArrayList<>();
        dfs(0,adj,vis);
        
        return dfsArray;
    }
}



6. Rotten Oranges ( https://takeuforward.org/data-structure/rotten-oranges/)


Problem Link:: https://www.geeksforgeeks.org/problems/rotten-oranges2536/1


Solution::


class Solution
{
    int cntFresh;
    public boolean isValid(int i ,int j, int n, int m)
    {
        if(i>=0 &&i<n && j>=0 &&j<m)
          return true;
        return false;
    }
    public int bfs(int [][] grid,int [][] vis,Queue<Pair> qp)
    {
      int cnt = 0;
      int n = grid.length;
      int m = grid[0].length;
      int dx[] = {-1, 0, 1, 0};
      int dy[] = {0, 1, 0, -1}; 
      while(!qp.isEmpty())
      {
        
              Pair p = qp.poll();
              int x = p.getKey();
              int y = p.getValue();
              int t = p.getTime();
              cnt = Math.max(t,cnt);
              for(int i=0;i<4;i++)
              {
                  int newX = x+dx[i];
                  int newY = y+dy[i];
                  if(isValid(newX,newY,n,m) && grid[newX][newY]==1 && vis[newX][newY]==0)
                  {
                      vis[newX][newY]=1;
                      qp.add(new Pair(newX,newY,t+1));
                      cntFresh--;
                  }
              }

      }
      
      return cntFresh==0?cnt:-1;
    }
    
    //Function to find minimum time required to rot all oranges. 
    public int orangesRotting(int[][] grid)
    {
        // Code here
        int n = grid.length;
        int m = grid[0].length;
        int vis[][]=new int [n][m];
        Queue<Pair> qp = new LinkedList<>();
        cntFresh=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                vis[i][j]=0;
                if(grid[i][j]==2)
                   {
                       qp.add(new Pair(i,j,0));
                       vis[i][j]=1;
                   }
                if(grid[i][j]==1)
                  cntFresh++;
            }
        }
        
      return  bfs(grid,vis,qp);
    }
}

class Pair {
    private Integer key;
    private Integer value;
    private Integer time;
    
    public Integer getKey()
    {
        return this.key;
    }
    public Integer getValue()
    {
        return this.value;
    }
    
     public Integer getTime()
    {
        return this.time;
    }
    
    Pair(Integer key,Integer value,Integer time)
    {
        this.key=key;
        this.value=value;
        this.time=time;
    }
}




7. Detect Cycle in an Undirected Graph (using BFS) (https://takeuforward.org/data-structure/detect-cycle-in-an-undirected-graph-using-bfs/)


Problem Link:: https://www.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1



Solution::


class Solution {
    
   public boolean bfs(int src,ArrayList<ArrayList<Integer>> adj,boolean vis[])
   {
    
        Queue<Pair> qp = new LinkedList<>();
        vis[src] = true;
        qp.add(new Pair(src,-1));
        
        while(!qp.isEmpty())
        {
           
            int node = qp.peek().node;
            int parent = qp.peek().parent;
            
            qp.remove();
            
            for(Integer it:adj.get(node))
            {
                if(vis[it]==false)
                {
                  vis[it] = true;
                  qp.add(new Pair(it,node));
                }
                else if(parent!=it)
                     return true;
            }
        }
        return false;
   }
    // Function to detect cycle in an undirected graph.
    public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {
        // Code here
        
        boolean vis[] = new boolean[V];
        Arrays.fill(vis,false);
        for(int i = 0;i<V;i++) 
            if(vis[i]==false)
                if(bfs(i, adj, vis))
                     return true;
        
        return false;
        
    }
}

class Pair {

   int node;
   int parent;
   
   Pair(int node,int parent)
   {
       this.node = node;
       this.parent = parent;
   }
   
}




8. Detect Cycle in an Undirected Graph (using DFS) (https://takeuforward.org/data-structure/detect-cycle-in-an-undirected-graph-using-dfs/)


Problem Link:: https://www.geeksforgeeks.org/problems/detect-cycle-in-an-undirected-graph/1


Solution::



class Solution {
    
    public boolean dfs(int node,ArrayList<ArrayList<Integer>> adj, int vis[],int parent)
    {
        vis[node] = 1;
        for(Integer it:adj.get(node))
        {
            
            if(vis[it]==0)
             {
                if(dfs(it,adj,vis,node)==true)
                  return true;   
             }
               
          else if(it!=parent)
            return true;
        }
        
        return false;
    }
    // Function to detect cycle in an undirected graph.
    public boolean isCycle(int V, ArrayList<ArrayList<Integer>> adj) {
        // Code here
        
        int vis[] = new int [V];
        Arrays.fill(vis,0);
        
        for(int i=0;i<V;i++)
        {
            if(vis[i]==0)
            {
                vis[i] = 1;
                if(dfs(i,adj,vis,-1))
                  return true;
            }
        }
        
        return false;
    }
}





